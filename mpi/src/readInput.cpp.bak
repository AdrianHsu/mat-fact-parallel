#include <cstring>
#include "readInput.h"

#define READ_INPUT 123
#define NUMBER_OF_LINES 132
#define SEND_MATRIX 132
#define SEND_SIZES 131
#define ROOT 0

#define FIRST_ELEMENT(id, p, n) ((id)*(n)/(p))
#define LAST_ELEMENT(id, p, n) (FIRST_ELEMENT((id)+1,p,n)-1)
#define BLOCK_SIZE(id, p, n) (LAST_ELEMENT(id,p,n)-FIRST_ELEMENT(id,p,n)+1)

void readInput(std::string &inputFileName, std::vector<std::vector<double>> &A,
               std::vector<int> &nonZeroUserIndexes, std::vector<int> &nonZeroItemIndexes,
               std::vector<double> &nonZeroElements,
               int &numberOfIterations, int &numberOfFeatures, double &convergenceCoefficient, int &numberOfUsers,
               int &numberOfItems, int &numberOfNonZeroElements, int &processId, int &numberOfProcesses) {


    std::vector<std::string> fileCopy;
    std::string line;

    int numberOfLines, StoreNumberOfIterations, StoreNumberOfFeatures,
            StoreNumberOfUsers, StoreNumberOfItems, StoreNumberOfNonZeroElements;
    double StoreConvergenceCoefficient;


    // GET COPY AND NUMBER OF LINES
    if (processId == ROOT) {
        std::ifstream countFileLines(inputFileName);
        for (numberOfLines = 0; std::getline(countFileLines, line); numberOfLines++) {
            fileCopy.push_back(line);
        };
        countFileLines.close();
    }

    MPI_Bcast(&numberOfLines, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
    printf("process %d has numberOfLines %d\n", processId, numberOfLines);
    fflush(stdout);

    if (processId == ROOT) {
        for (int k = 0; k < 4; k++) {
            line = fileCopy[k];
            switch (k) {
                case 0: {
//                    StoreNumberOfIterations = std::stoi(line);
                    numberOfIterations = std::stoi(line);
                    break;
                }
                case 1: {
//                    StoreConvergenceCoefficient = std::stod(line);
                    convergenceCoefficient = std::stod(line);
                    break;
                }
                case 2: {
//                    StoreNumberOfFeatures = std::stoi(line);
                    numberOfFeatures = std::stoi(line);
                    break;
                }
                case 3: {
                    std::istringstream iss(line);

                    std::vector<std::string> results(std::istream_iterator<std::string>{iss},
                                                     std::istream_iterator<std::string>());
                    numberOfUsers = std::stoi(results[0]);
//                    StoreNumberOfUsers = std::stoi(results[0]);
//                    StoreNumberOfItems = std::stoi(results[1]);
                    numberOfItems = std::stoi(results[1]);
//                    StoreNumberOfNonZeroElements = std::stoi(results[2]);
                    numberOfNonZeroElements = std::stoi(results[2]);
                    break;
                }
            }
        }
    }

//    MPI_Bcast(&StoreNumberOfUsers, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
    MPI_Bcast(&numberOfUsers, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
//    numberOfUsers = StoreNumberOfUsers;
//    printf("process %d has StoreNumberOfUsers %d\n", processId, StoreNumberOfUsers);
    printf("process %d has numberOfUsers %d\n", processId, numberOfUsers);
    fflush(stdout);

//    MPI_Bcast(&StoreNumberOfItems, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
    MPI_Bcast(&numberOfItems, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
//    numberOfItems = StoreNumberOfItems;
//    printf("process %d has StoreNumberOfItems %d\n", processId, StoreNumberOfItems);
    printf("process %d has numberOfItems %d\n", processId, numberOfItems);
    fflush(stdout);

    MPI_Bcast(&numberOfNonZeroElements, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
//    MPI_Bcast(&StoreNumberOfNonZeroElements, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
//    numberOfNonZeroElements = StoreNumberOfNonZeroElements;
    printf("process %d has numberOfNonZeroElements %d\n", processId, numberOfNonZeroElements);
//    printf("process %d has StoreNumberOfNonZeroElements %d\n", processId, StoreNumberOfNonZeroElements);
    fflush(stdout);


    std::vector<std::vector<double>> ResizeA(numberOfUsers, std::vector<double>(numberOfItems, 0));
    A = ResizeA;

    std::vector<int> ResizeIndexes(numberOfNonZeroElements);
    nonZeroUserIndexes = ResizeIndexes;
    nonZeroItemIndexes = ResizeIndexes;

    std::vector<double> ResizeElements(numberOfNonZeroElements);
    nonZeroElements = ResizeElements;

//    int StoreNonZeroUserIndexes[StoreNumberOfNonZeroElements];
//    int StoreNonZeroItemIndexes[StoreNumberOfNonZeroElements];
//    double StoreNonZeroElements[StoreNumberOfNonZeroElements];


    if (processId == ROOT) {
//        for (int m = 0; m < StoreNumberOfNonZeroElements; m++) {
        for (int m = 0; m < numberOfNonZeroElements; m++) {
            line = fileCopy[m + 4];
            std::istringstream iss(line);
            std::vector<std::string> results(std::istream_iterator<std::string>{iss},
                                             std::istream_iterator<std::string>());
            int userIndex = std::stoi(results[0]);
            int itemIndex = std::stoi(results[1]);
            double element = std::stod(results[2]);
//
////            StoreA[userIndex][itemIndex] = element;
//            StoreNonZeroUserIndexes[m] = userIndex;
            nonZeroUserIndexes[m] = userIndex;
//            StoreNonZeroItemIndexes[m] = itemIndex;
            nonZeroItemIndexes[m] = itemIndex;
//            StoreNonZeroElements[m] = element;
            nonZeroElements[m] = element;
        }
    }

//    MPI_Bcast(&StoreNumberOfNonZeroElements, 1, MPI_INT, ROOT, MPI_COMM_WORLD);
    MPI_Bcast(&numberOfNonZeroElements, 1, MPI_INT, ROOT, MPI_COMM_WORLD);

    // DIVIDE THIS
//    MPI_Bcast(&StoreNonZeroUserIndexes[0], StoreNumberOfNonZeroElements, MPI_INT, ROOT, MPI_COMM_WORLD);
//    MPI_Bcast(&StoreNonZeroItemIndexes[0], StoreNumberOfNonZeroElements, MPI_INT, ROOT, MPI_COMM_WORLD);
//    MPI_Bcast(&StoreNonZeroElements[0], StoreNumberOfNonZeroElements, MPI_DOUBLE, ROOT, MPI_COMM_WORLD);

    MPI_Bcast(&nonZeroUserIndexes[0], numberOfNonZeroElements, MPI_INT, ROOT, MPI_COMM_WORLD);
    MPI_Bcast(&nonZeroItemIndexes[0], numberOfNonZeroElements, MPI_INT, ROOT, MPI_COMM_WORLD);
    MPI_Bcast(&nonZeroElements[0], numberOfNonZeroElements, MPI_DOUBLE, ROOT, MPI_COMM_WORLD);


//    for (int n = 0; n < numberOfNonZeroElements; n++) {
//        std::cout << nonZeroUserIndexes[n] << " StoreNonZeroUserIndexes OK process " << processId << std::endl;
//        fflush(stdout);
//    }

    std::vector<std::vector<double>> StoreA(numberOfUsers, std::vector<double>(numberOfItems, 0));

    if (processId != ROOT) {
        for (int l = 0; l < numberOfNonZeroElements; l++) {
            StoreA[nonZeroUserIndexes[l]][nonZeroItemIndexes[l]] = nonZeroElements[l];
            std::cout << nonZeroUserIndexes[l] << ", " << nonZeroItemIndexes[l] << std::endl;
        }
    }

//    double MatrixA[StoreNumberOfUsers][StoreNumberOfItems];
//    if (processId == ROOT) {
//        for (int i = 0; i < StoreNumberOfUsers; i++) {
//            for (int j = 0; j < StoreNumberOfItems; j++) {
//                MatrixA[i][j] = 0;
//            }
//        }
//    }

    MPI_Reduce(&StoreA[0][0], &A[0][0], numberOfUsers * numberOfItems, MPI_DOUBLE, MPI_MAX, ROOT,
               MPI_COMM_WORLD);

    printf("process %d ended readInput\n", processId);

}
